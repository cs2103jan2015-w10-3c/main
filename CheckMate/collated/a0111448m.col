//@author: a0111448m



	/**
	 * origin: C:\users\joseph\desktop\v0.5\cmcode\CMLogic\ClashCheck.cpp
	 */

#include "ClashCheck.h"


bool ClashCheck :: checkClash (std::vector <Task*> taskList ,boost::posix_time::ptime newStart,boost::posix_time::ptime newEnd){
	bool isClash = false;

	for(unsigned int index =0; ((index < taskList.size())&&(isClash==false));index++){
		isClash=taskList[index]->hasClash(newStart,newEnd);
	}
	return isClash;
}

	// End of segment: C:\users\joseph\desktop\v0.5\cmcode\CMLogic\ClashCheck.cpp





	/**
	 * origin: C:\users\joseph\desktop\v0.5\cmcode\CMLogic\ClashCheck.h
	 */

#ifndef CLASHCHECK_H
#define CLASHCHECK_H

#include <iostream>

#include "Task.h"
#include "TimedTask.h"
#include "Deadline.h"
#include "FloatingTask.h"
#include "boost/date_time.hpp"

//Helps LogicCommand to check for a clash whenever
//User adds a Timed Task. CheckMate will only serve 
//to inform the user of a clash and the User will 
//'undo his actions if he wants'
class ClashCheck{
public:
	//Check if Boundary of aNew task clashes with any other Task
	bool checkClash (std::vector<Task*>,boost::posix_time::ptime,boost::posix_time::ptime);
};
#endif
	// End of segment: C:\users\joseph\desktop\v0.5\cmcode\CMLogic\ClashCheck.h





	/**
	 * origin: C:\users\joseph\desktop\v0.5\cmcode\CMLogic\CMLogic.cpp
	 */

#include <iostream>
#include <vector>
#include <string>

#include "CMLogic.h"



CMLogic::CMLogic(){
	_isActive= true;
}

void CMLogic :: startUp(){
	_display=_commandExecutor.retrieveData();
	std::cout<<"CMLOGIC :"<<"Retrieved Data"<<std::endl;
	return;
}


void CMLogic :: executeCommand(std::string input){
	std::cout<<"1. CMLOGIC :"<<"Executing Command"<<std::endl;
	//Obtains index for switch and Description behind
	Command* newCommand = _commandReader.interpretCommand(input);
	int commandIndex = newCommand->getCommandIndex();
	std::string commandDescription=newCommand->getCommandDescription();
	
	switch(commandIndex){
					//AddTask
	case INDEXADD :{ 
		_display= _commandExecutor.addTask(commandDescription,FROMUSER,ACTIVETASK); 

				   }
				   break;

				   //Search all mathcing Task
	case INDEXSEARCH:{   
		_display  = _commandExecutor.searchTask(commandDescription);
					 }
					 break;

					 //Edit a task
	case INDEXEDIT:{
		_display = _commandExecutor.editTask(commandDescription);
				   }
				   break;

				   //Delete task
	case INDEXDELETE:{ 
		_display = _commandExecutor.deleteTask(commandDescription);
					 }
					 break;

					 //Search for all Task Today
	case INDEXTODAY:{
		_display = _commandExecutor.displayToday();
					}
					break;

					//Search for all Task Tommorrow
	case INDEXTOMORROW:{
		_display = _commandExecutor.displayTomorrow();
					   }
					   break;

					   //Undo previous action
	case INDEXUNDO	:{
		_display=_commandExecutor.undoAction();
					 }
					 break;
					
				   //Clear all Task
	case INDEXCLEAR:{
		_display=_commandExecutor.clearTask();
					}
					break;

					//check an index Task
	case INDEXCHECKTASK	:{
		_display=_commandExecutor.checkTask(commandDescription);
						 }
						 break;
						 //closes the Program
	case INDEXCOMPLETED:{
		_display=_commandExecutor.checkCompletedTask();
						}
						break;

	case INDEXUNCHECK:{
		_display=_commandExecutor.uncheckTask(commandDescription);
					  }
					  break;
	case INDEXCHANGESTORE:{
		_display=_commandExecutor.changeStorageDirectory(commandDescription);
						  }
						  break;
	case INDEXHOME:{
		_display=_commandExecutor.returnToHomePage();
						  }
						  break;

						  //Invalid Input
	default:{
		_display->editFeedback(INVALID_INPUT);
			}
			break;
	}

	return;

}

Output*  CMLogic :: getDisplay(){
	std::cout<<"CMLogic :"<<"Sends output to GUI"<<std::endl;
	return _display;
}


	// End of segment: C:\users\joseph\desktop\v0.5\cmcode\CMLogic\CMLogic.cpp





	/**
	 * origin: C:\users\joseph\desktop\v0.5\cmcode\CMLogic\CMLogic.h
	 */

#ifndef CMLOGIC_H
#define CMLOGIC_H

#include <iostream>
#include <vector>

#include "LogicCommand.h"
#include "LogicRead.h"
#include "Command.h"
#include "Output.h"

//Serves as the API to the GUI.  All inputs will first
//Enter the CMLogic who relies on the LogicRead to interpret 
//the command and LogicCommand to excute it. The GUI should only
//be able to access the feedback and Tasklist 
class CMLogic{
private:
	LogicCommand _commandExecutor;		//To execute actions
	LogicRead _commandReader;			//To interpret the user input
	bool _isActive;						//Status of system
	Output* _display;					// Display for GUI

public:
	CMLogic();
	void startUp();						//Retrieve Task from the saved text files
	void executeCommand(std::string);	//Exceutes the commands of the User
	Output* getDisplay();				//For GUI to retrieve the display.
};
#endif

	// End of segment: C:\users\joseph\desktop\v0.5\cmcode\CMLogic\CMLogic.h





	/**
	 * origin: C:\users\joseph\desktop\v0.5\cmcode\CMLogic\Command.cpp
	 */

#include "Command.h"


Command::Command(int index,std::string input){
	_commandIndex = index;
	_commandDescription= input;
}

int Command::getCommandIndex() const{
	return _commandIndex;
}

std::string Command::getCommandDescription() const{
	return _commandDescription;
}

	// End of segment: C:\users\joseph\desktop\v0.5\cmcode\CMLogic\Command.cpp





	/**
	 * origin: C:\users\joseph\desktop\v0.5\cmcode\CMLogic\Command.h
	 */

#ifndef COMMAND_H
#define COMMAND_H

#include <iostream>

//An Object to store the Command Index 
//and command Description interpreted from
//LogicRead.
class Command{
private:
	int _commandIndex;					//Index for switch case
	std::string _commandDescription;	//Remainding details after command

public:
	Command(int,std::string);			//Creates a Command object for execution
	int getCommandIndex() const;		
	std::string getCommandDescription() const ;
};

#endif

	// End of segment: C:\users\joseph\desktop\v0.5\cmcode\CMLogic\Command.h





	/**
	 * origin: C:\users\joseph\desktop\v0.5\cmcode\CMLogic\Deadline.cpp
	 */

#include "Deadline.h"
#include <iomanip>
#include <sstream>
#include <algorithm>
#include <string>


Deadline::Deadline(std::string description,boost::posix_time::ptime end)
	:Task(description){ 
		_end = end;
}

Deadline::~Deadline(void){
}

void Deadline:: editStartDate(boost::posix_time::ptime newStart){
	return;
}
void Deadline:: editStartTime (boost::posix_time::ptime newStart){
	return;
}

void Deadline:: editEndDate (boost::posix_time::ptime newEnd){
	_end= newEnd;
}
void Deadline:: editEndTime (boost::posix_time::ptime newEnd){
	_end=newEnd;
}


boost::posix_time::ptime Deadline:: getStart() const{
	return boost::posix_time::ptime() ; 
}


boost::posix_time::ptime Deadline:: getEnd() const{
	return _end;
}


bool Deadline :: hasClash(boost::posix_time::ptime newStart,boost::posix_time::ptime newEnd){
	return NOCLASH;
}

bool Deadline:: isFound (std::string keyword){

	bool found = false;
	size_t position;

	position = _description.find(keyword);
	if(position!= std::string::npos){
		found = true;
	}

	position = to_simple_string(_end).find(keyword);
	if(position!= std::string::npos){
		found = true;
	}

	return found;
}

std:: string Deadline:: getInfo() {
	std::ostringstream information;

	information <<std::left<< std::setw(60)<<_description
		<<std::setw(30)<<"      --NIL--"
		<<std::setw(30)<<to_simple_string(_end);


	return information.str();
}	

bool Deadline :: isFloat(){
	return false;
}

bool Deadline :: isTimed(){
	return false;
}

bool Deadline :: isDeadline(){
	return true;
}

bool Deadline :: isEditedTask(std::string description, boost::posix_time::ptime start, boost::posix_time::ptime end){
	if(description==_description && start == boost::posix_time::ptime()&& end == _end){
		return true;
	} else {
		return false;
	}
}
	// End of segment: C:\users\joseph\desktop\v0.5\cmcode\CMLogic\Deadline.cpp





	/**
	 * origin: C:\users\joseph\desktop\v0.5\cmcode\CMLogic\Deadline.h
	 */

#ifndef DEADLINE_H
#define DEADLINE_H

#include "Task.h"

//Deadline is a task which contains only the
//description for the user to relate and the date 
//which the deadline needs to be done. Both description
//and deadline will be shown to the user on the UI.
//Deadline is a subclass of Task.
class Deadline : public Task{ 
private:
	boost::posix_time::ptime _end;												// The deadline date and time

public:

	Deadline(std::string,boost::posix_time::ptime);
	~Deadline(void);
	virtual void editStartDate(boost::posix_time::ptime);
	virtual void editStartTime (boost::posix_time::ptime);
	virtual void editEndDate (boost::posix_time::ptime);
	virtual void editEndTime (boost::posix_time::ptime);

	virtual boost::posix_time::ptime getStart() const;
	virtual boost::posix_time::ptime getEnd() const;

	virtual bool hasClash(boost::posix_time::ptime,boost::posix_time::ptime);	//Deadlines do not have clashes
	virtual std::string getInfo();
	virtual bool isFound(std::string);
	virtual bool isEditedTask(std::string, boost::posix_time::ptime, boost::posix_time::ptime);
	virtual bool isFloat();	
	virtual bool isTimed();
	virtual bool isDeadline();
};
#endif

	// End of segment: C:\users\joseph\desktop\v0.5\cmcode\CMLogic\Deadline.h





	/**
	 * origin: C:\users\joseph\desktop\v0.5\cmcode\CMLogic\EditReader.cpp
	 */

#include "EditReader.h"
#include <sstream>
#include <cctype>

EditReader::EditReader(void){
	int _taskIndex =-1;
	int _categoryindex = -1;
	std::string _newInput ="";
}


EditReader::~EditReader(void){
}

bool EditReader::interpretCommand(std::string CommandInput){
	//Find index of Searched Task
	std::istringstream editDetails(CommandInput);

	if(editDetails>>_taskIndex){
	}else{
		return false;
	}

	std::string Category;

	if(editDetails>>Category){
		_categoryIndex=indexCategory(Category);
	} else {
		_categoryIndex=INVALIDINDEX;
		_newInput="";
		return false;}					//Invalid Input


	if(getline(editDetails,_newInput)){
		_newInput=_newInput.substr(1);
		return true;} 
	else{
		_newInput="";
		return false;}
}

int EditReader::indexCategory(std::string category){

	std::string catergory = lowerCase(category); 

	if(catergory==DESCRIPTION){
		return DESCRIPTIONINDEX;}
	else if
		(catergory==STARTTIME){
			return STARTTIMEINDEX;
	}else if
		(catergory==ENDTIME){
			return ENDTIMEINDEX;
	}else if
		(catergory==STARTDATE){
			return STARTDATEINDEX;
	}else if
		(catergory==ENDDATE){
			return ENDDATEINDEX;
	}else
		return INVALIDINDEX;
}

std::string EditReader :: lowerCase(std::string commandInput){

	char newCase;
	for(unsigned int index = 0; index < commandInput.size();index++){
		if(isupper(commandInput[index])){ 
			newCase= tolower(commandInput[index]);
			commandInput[index] = newCase;
		}
	}
	return commandInput;
}

int EditReader:: getTaskIndex() const {
	return _taskIndex;
}

int EditReader:: getSelectedCategory() const {
	return _categoryIndex;
}

std::string EditReader:: getNewInput() const {
	return _newInput;
}
	// End of segment: C:\users\joseph\desktop\v0.5\cmcode\CMLogic\EditReader.cpp





	/**
	 * origin: C:\users\joseph\desktop\v0.5\cmcode\CMLogic\EditReader.h
	 */

#ifndef EDITREADER_H
#define EDITREADER_H

#include<iostream>
#include<string>

const std::string DESCRIPTION="desc";
const std::string STARTTIME = "stime";
const std::string ENDTIME = "etime";
const std::string STARTDATE = "sdate";
const std::string ENDDATE = "edate";

const int DESCRIPTIONINDEX= 1;
const int STARTTIMEINDEX= 2;
const int ENDTIMEINDEX= 3;
const int STARTDATEINDEX= 4;
const int ENDDATEINDEX= 5;
const int INVALIDINDEX=20;

//Serves as a reader to interpret a string input into an index of the Task selected,
//the type of category chosen( Description, start time, start date, end time, end date)
//and the new infomartion to update. It is assumed the user know the category keywords
class EditReader{ 

private:
	int _taskIndex;							//Index of selected task Displayed
	int _categoryIndex;						//Index of Description/Start/End
	std::string _newInput;					//New input to replace previous


public:
	EditReader(void);
	~EditReader(void);
	bool interpretCommand(std::string);		//Retruns false if line is Invalid
	int indexCategory(std::string);			//Indexes the category for switch case
	std::string lowerCase(std::string);		//Allows Logic to read upper and lowercase
	int getTaskIndex() const;
	int getSelectedCategory() const;
	std::string getNewInput() const;
};

#endif
	// End of segment: C:\users\joseph\desktop\v0.5\cmcode\CMLogic\EditReader.h





	/**
	 * origin: C:\users\joseph\desktop\v0.5\cmcode\CMLogic\FloatingTask.cpp
	 */

#include "FloatingTask.h"
#include <sstream>
#include <iomanip>
#include <string>



FloatingTask::FloatingTask(std::string description)
	:Task(description){}


FloatingTask::~FloatingTask(void)
{}

void FloatingTask:: editStartDate(boost::posix_time::ptime NewStart){
	return;
}

void FloatingTask:: editStartTime (boost::posix_time::ptime NewStart){
	return;
}
void FloatingTask:: editEndDate (boost::posix_time::ptime NewEnd){
	return;
}
void FloatingTask:: editEndTime (boost::posix_time::ptime NewEnd){
	return;
}

boost::posix_time::ptime FloatingTask:: getStart() const{
	return boost::posix_time::ptime(); }


boost::posix_time::ptime FloatingTask:: getEnd() const{
	return boost::posix_time::ptime();
}

bool FloatingTask :: hasClash(boost::posix_time::ptime newStart, boost::posix_time::ptime newEnd){
	return NOCLASH;
}


bool FloatingTask :: isFound(std::string keyword){
	bool found = false;
	size_t position;

	position = _description.find(keyword);
	if(position!= std::string::npos)
	{return true;}


	return found;
}

std::string FloatingTask:: getInfo() {
	std::ostringstream information;

	information <<std::left << std::setw(60)<<_description
		<<std::setw(30)<<"      --NIL--"
		<<std::setw(30)<<"      --NIL--";

	return information.str();
}

bool FloatingTask :: isFloat(){
	return true;
}

bool FloatingTask :: isTimed(){
	return false;
}

bool FloatingTask :: isDeadline(){
	return false;
}

bool FloatingTask :: isEditedTask(std::string description, boost::posix_time::ptime start, boost::posix_time::ptime end){
	if(description==_description && start == boost::posix_time::ptime()&& end == boost::posix_time::ptime()){
		return true;
	} else {
		return false;}
}
	// End of segment: C:\users\joseph\desktop\v0.5\cmcode\CMLogic\FloatingTask.cpp





	/**
	 * origin: C:\users\joseph\desktop\v0.5\cmcode\CMLogic\FloatingTask.h
	 */

#ifndef FLOATINGTASK_H
#define FLOATINGTASK_H

#include <iostream>
#include "Task.h"

//FloatingTask is a task which contains only the
//description for the user to relate. This Description
//will be shown to the user on the UI serperate from the other type of Task
//and he will be able to search, delete and edit a FloatingTask
//Floating Task is a subclass of Task.
class FloatingTask : public Task
{
public:
	FloatingTask(std::string);
	~FloatingTask(void);

	virtual void editStartDate(boost::posix_time::ptime);
	virtual void editStartTime (boost::posix_time::ptime);
	virtual void editEndDate (boost::posix_time::ptime);
	virtual void editEndTime (boost::posix_time::ptime);

	virtual boost::posix_time::ptime getStart() const;
	virtual boost::posix_time::ptime getEnd() const; 

	virtual bool hasClash(boost::posix_time::ptime,boost::posix_time::ptime);
	virtual bool isFound(std::string);
	virtual std::string getInfo();
	virtual bool isEditedTask(std::string, boost::posix_time::ptime, boost::posix_time::ptime);
	virtual bool isFloat();	
	virtual bool isTimed();
	virtual bool isDeadline();
};
#endif

	// End of segment: C:\users\joseph\desktop\v0.5\cmcode\CMLogic\FloatingTask.h





	/**
	 * origin: C:\users\joseph\desktop\v0.5\cmcode\CMLogic\LogicCommand.cpp
	 */

#include "LogicCommand.h"

Output*  LogicCommand :: retrieveData(){
	Output* output;
	//Add Task from textfiles back
	std::vector<std::string> _toDisplay=_storage.readFile();		
	for(unsigned int index=0; index < _toDisplay.size(); index++){
		output = addTask(_toDisplay[index],FROMFILE,ACTIVETASK);
	} 
	//Add Completed Files from textfiles back
	std::vector<std::string> archivedFileList = _storage.readArchivedFile();
	for(unsigned int index=0; index < archivedFileList.size(); index++){
		output = addTask(archivedFileList[index],FROMFILE,COMPLETEDTASK);
	} 
	_taskList =_storage.getActiveDisplay();
	_firstFloatIndex=_storage.getIndexFirstFloat();
	_lastActionIndex= NONOBSERVABLE;
	_feedback = WELCOMEBACK;
	_listType= ACTIVETASK;

	output= new Output(_feedback,_taskList,_lastActionIndex,_firstFloatIndex,_listType);
	return output;

}


Output*  LogicCommand :: addTask(std::string commandInput,int InputSource=FROMUSER,bool isCompleted=ACTIVETASK){


	if(InputSource==FROMFILE){                          
		_parser.parseDataFromFile(commandInput);
	}else{												
		_parser.parseData(commandInput);
	}

	std::string taskType = _parser.getType();

	if(taskType==TIMEDTYPE){
		Output* output= addTimeTask(isCompleted);
		return output;	
	}else if
		(taskType==FLOATINGTYPE){
			Output*  output= addFloatTask(isCompleted);
			return output;
	}else if
		(taskType==DEADLINE){
			Output*  output= addDeadlines(isCompleted);
			return output;
	}else{ 
		std::string feedback = INVALIDTYPE;
		_taskList =_storage.getActiveDisplay();
		
		Output*  output= new Output(feedback,_taskList,_lastActionIndex,_firstFloatIndex,_listType);
		return output;}
}

Output* LogicCommand :: addFloatTask(bool isCompleted){
	std::string description =_parser.getDescription();

	FloatingTask* newFloatingTask = new FloatingTask(description);
	if(isCompleted){
		_storage.addArchivedFloatingTask(newFloatingTask);
		_lastActionIndex=NONOBSERVABLE;
	}else if
		(!isCompleted){
			_storage.addFloatingTask(newFloatingTask);
			_lastActionIndex=_storage.getAddedIndex();}

	_taskList =_storage.getActiveDisplay();
	_firstFloatIndex=_storage.getIndexFirstFloat();
	_feedback = description + ADDED;

	Output* output= new Output(_feedback,_taskList,_lastActionIndex,_firstFloatIndex,_listType);
	return output;
}


Output* LogicCommand :: addDeadlines(bool isCompleted){
	std::string description =_parser.getDescription();
	boost::posix_time::ptime end = _parser.getEnd();

	Deadline* NewDeadline = new Deadline(description,end);

	if(isCompleted){
		_storage.addArchivedDeadline(NewDeadline);
		_lastActionIndex=NONOBSERVABLE;
	}else if
		(!isCompleted){
			_storage.addDeadline(NewDeadline);
			_lastActionIndex=_storage.getAddedIndex();}

	_taskList =_storage.getActiveDisplay();
	_firstFloatIndex=_storage.getIndexFirstFloat();
	_feedback = description + ADDED;

	Output* output= new Output(_feedback,_taskList,_lastActionIndex,_firstFloatIndex,_listType);
	return output;
}

Output* LogicCommand :: addTimeTask(bool isCompleted){

	std::string description =_parser.getDescription();

	boost::posix_time::ptime Start = _parser.getStart(); // To identify a deadline and TimedTask
	boost::posix_time::ptime End = _parser.getEnd();

	_taskList =_storage.getActiveDisplay();


	bool hasClash = _checker.checkClash(_taskList,Start,End);

	if(hasClash){
		_feedback =  CLASHED ; 
	} else if
		(!hasClash){
			_feedback = description + ADDED;
	}
	TimedTask* newTimedTask = new TimedTask(description,Start,End);

	if(isCompleted){
		_storage.addArchivedTimedTask(newTimedTask);
		_lastActionIndex=NONOBSERVABLE;}
	else if
		(!isCompleted){
			_storage.addTimedTask(newTimedTask);
			_lastActionIndex=_storage.getAddedIndex();}
	_taskList =_storage.getActiveDisplay();
	_firstFloatIndex=_storage.getIndexFirstFloat();

	Output* output= new Output(_feedback,_taskList,_lastActionIndex,_firstFloatIndex,_listType);
	return output;
}

Output* LogicCommand :: searchTask (std::string commandInput){
	if(commandInput==""){
		_taskList =_storage.getActiveDisplay();
		_feedback = NOTFOUND;
	} else {
		_taskList = _storage.getSearchedTasks(commandInput);
		if(_taskList.empty()){
			_feedback = NOTFOUND;
			_firstFloatIndex = _taskList.size();
		}else {
			_feedback = SEARCHFOUND + TASKS;
			_firstFloatIndex = _taskList.size();
		}
	}
	_lastActionIndex = NONOBSERVABLE;
	

	Output* output= new Output(_feedback,_taskList,_lastActionIndex,_firstFloatIndex,_listType);
	return output;
}

Output* LogicCommand :: deleteTask(std::string selectedIndexes){
	_storage.updateHistory();
	_feedback="";
	std::vector<int> indexVector =_stringConvertor.toInt(selectedIndexes);
	
	for(unsigned int index=0;index<indexVector.size();index++){
		int taskIndex = indexVector[index];
		_feedback = _feedback + _storage.deleteTask(taskIndex);
	}

	_taskList =_storage.getActiveDisplay();
	_lastActionIndex= NONOBSERVABLE;
	_firstFloatIndex=_storage.getIndexFirstFloat();

	Output* output= new Output(_feedback,_taskList,_lastActionIndex,_firstFloatIndex,_listType);
	return output;
}

Output* LogicCommand :: editTask(std::string commandInput){
	std::string _feedback;
	bool isValidInput=true;
	isValidInput=_editor.interpretCommand(commandInput);
	Task* selectedTask;
	_taskList =_storage.getActiveDisplay();
	if(isValidInput&&(_editor.getTaskIndex()<=_taskList.size())){
		int taskIndex =_editor.getTaskIndex();
		selectedTask= _storage.getTask(taskIndex);


		int editCommandIndex = _editor.getSelectedCategory();
		std::string editedInput = _editor.getNewInput();

		switch(editCommandIndex){
		case DESCRIPTIONINDEX:{
			selectedTask->editDescription(editedInput);
			_feedback=EDITED;}
							  break;
		case STARTTIMEINDEX:{
			boost::posix_time::ptime previousTime = selectedTask->getStart();
			boost::posix_time::ptime newStart = _parser.changeTime(previousTime,editedInput);
			selectedTask->editStartTime(newStart);
			_feedback=EDITED;}
							break;
		case STARTDATEINDEX:{
			boost::posix_time::ptime previousDate = selectedTask->getStart();
			boost::posix_time::ptime newStart = _parser.changeDate(previousDate,editedInput);
			selectedTask->editStartDate(newStart);
			_feedback=EDITED;}
							break;
		case ENDTIMEINDEX:{
			boost::posix_time::ptime previousTime = selectedTask->getEnd();
			boost::posix_time::ptime newEnd = _parser.changeTime(previousTime,editedInput);
			selectedTask->editEndTime(newEnd);
			_feedback=EDITED;}
						  break;

		case ENDDATEINDEX:{
			boost::posix_time::ptime previousDate = selectedTask->getEnd();
			boost::posix_time::ptime newEnd = _parser.changeDate(previousDate,editedInput);
			selectedTask->editEndDate(newEnd);
			_feedback=EDITED;}
						  break;
		default:{
			_feedback= INVALIDTYPE;}
				break;
		}
	}else {_feedback= INVALIDTYPE;}

	_storage.writeEditedFile();
	_taskList =_storage.getActiveDisplay();
	if(_feedback!= INVALIDTYPE){
		_lastActionIndex = _storage.getEditedIndex(selectedTask->getDescription(),selectedTask->getStart(),selectedTask->getEnd());
	} 

	Output* output= new Output(_feedback,_taskList,_lastActionIndex,_firstFloatIndex,_listType);
	return output;


}

Output* LogicCommand :: displayToday(){

	std::string today = _parser.getToday();
	Output* output= searchTask(today);
	_listType= ACTIVETASK;
	return output;
}

Output* LogicCommand ::  displayTomorrow(){

	std::string tomorrow = _parser.getTomorrow();
	Output* output= searchTask(tomorrow);
	_listType= ACTIVETASK;
	return output;
}


Output* LogicCommand :: undoAction(){
	_storage.undoAction();

	_taskList =_storage.getActiveDisplay();
	_lastActionIndex = NONOBSERVABLE;
	_firstFloatIndex= _storage.getIndexFirstFloat();

	_feedback= UNDID;


	Output* output= new Output(_feedback,_taskList,_lastActionIndex,_firstFloatIndex,_listType);
	return output;

}


Output* LogicCommand :: checkTask(std::string selectedIndexes){

	_storage.updateHistory();
	_storage.updateArchivedHistory();

	std::vector<int> indexVector =_stringConvertor.toInt(selectedIndexes);
	_feedback="";

	for(unsigned index=0;index<indexVector.size();index++){
		_feedback = _storage.check(indexVector[index]) + '\n' +_feedback;
	}
	_taskList =_storage.getActiveDisplay();
	_feedback= _feedback + CHECKED;

	_firstFloatIndex = _storage.getIndexFirstFloat();
	_lastActionIndex =NONOBSERVABLE;

	Output* output= new Output(_feedback,_taskList,_lastActionIndex,_firstFloatIndex,_listType);
	return output;
}

Output* LogicCommand :: uncheckTask(std::string selectedIndexes){
	
	_storage.updateHistory();
	_storage.updateArchivedHistory();

	std::vector<int> indexVector =_stringConvertor.toInt(selectedIndexes);
	_feedback="";

	Output* output;
	for(unsigned startindex=0;startindex<indexVector.size();startindex++){
		std::string uncheckTask = _storage.uncheck(indexVector[startindex]);
		output = addTask(uncheckTask,FROMFILE,ACTIVETASK);
		_feedback = uncheckTask + '\n' +_feedback;
	}
	_feedback= _feedback + CHECKED;

	output= checkCompletedTask();

	return output;
}

Output* LogicCommand :: clearTask(){
	_storage.clearTasks();

	_feedback=CLEARED;
	_taskList =_storage.getActiveDisplay();
	_lastActionIndex=NONOBSERVABLE;
	_firstFloatIndex=NONE;

	Output* output= new Output(_feedback,_taskList,_lastActionIndex,_firstFloatIndex,_listType);

	return output;

}

Output* LogicCommand :: changeStorageDirectory(std::string DirectoryInput){

	std::string NewDirectory =_parser.interpretDirectoryString(DirectoryInput);

	_storage.changeStorageLocation(NewDirectory);

	_taskList =_storage.getActiveDisplay();
	_feedback= NEWDIRECTORY + NewDirectory;

	Output* output= new Output(_feedback,_taskList,_lastActionIndex,_firstFloatIndex,_listType);
	return output;
}

Output* LogicCommand :: checkCompletedTask() {

	_taskList =_storage.getArchivedDisplay();
	_feedback = ARCHIVED;
	_lastActionIndex=NONOBSERVABLE;
	_firstFloatIndex=_taskList.size();
	_listType= COMPLETEDTASK;
	Output* output= new Output(_feedback,_taskList,_lastActionIndex,_firstFloatIndex,_listType);
	return output;
}

Output* LogicCommand :: returnToHomePage(){

	_taskList =_storage.getActiveDisplay();
	_feedback = "";
	_lastActionIndex=NONOBSERVABLE;
	_firstFloatIndex=_storage.getIndexFirstFloat();
	_listType= ACTIVETASK;
	Output* output= new Output(_feedback,_taskList,_lastActionIndex,_firstFloatIndex,_listType);
	return output;
}
	// End of segment: C:\users\joseph\desktop\v0.5\cmcode\CMLogic\LogicCommand.cpp





	/**
	 * origin: C:\users\joseph\desktop\v0.5\cmcode\CMLogic\LogicCommand.h
	 */

#ifndef LOGICCOMMAND_H
#define LOGICCOMMAND_H

#include <iostream>
#include <sstream>
#include <string>
#include <vector>

#include "CMParser.h"
#include "CMDateParser.h"
#include "CMTimeParser.h"
#include "CheckMateStorage.h"
#include "Output.h"
#include "Task.h"
#include "FloatingTask.h"
#include "Deadline.h"
#include "TimedTask.h"
#include "EditReader.h"
#include "boost/date_time.hpp"
#include "StringConvertor.h"
#include "ClashCheck.h"

//Feedback after each action is done
const std::string INVALID_INPUT		= "Invalid command given!";
const std::string FLOATINGTYPE		= "float";
const std::string TIMEDTYPE			= "timed";
const std::string DEADLINE			= "deadline";
const std::string ADDED				= " was added!";
const std::string DELETED			= " was deleted!";
const std::string EDITED			= "Edit Done!";
const std::string SEARCHFOUND		= "Found";
const std::string TASKS				= " tasks.";
const std::string INVALIDTASKTYPE	= "Invalid Task Type Chosen!";
const std::string INVALIDTYPE		= "Invalid Category Chosen!";
const std::string UNDID				= "Action was undone!";
const std::string GOODBYE			= "Goodbye! ";
const std::string WELCOMEBACK		= "Welcome Back!";
const std::string NEWDIRECTORY		= "Directory Changed to ";
const std::string CHECKED			= "It has been checked";
const std::string CLEARED			= "All Task have been cleared!";
const std::string SAVED				= "Files have been saved";
const std::string ARCHIVED			= "These are the Completed Task.";
const std::string CLASHED			= "There is a clash with this appointment!";
const std::string NOTFOUND			= "No Task were Found";

const int NOINDEX					= -1;
const int FROMFILE					= 1;
const int FROMUSER					= 2;
const int NONOBSERVABLE				= -1;
const int NONE						= 0;
//For Add method to differentiate an archived task to a current task
const bool ACTIVETASK			= false;
const bool COMPLETEDTASK		= true;

//LogicCommand contains the meethods to execute the commands interprets in CMLogic.
//It is the component which utilizes the Parser and Storage components to interpret
//and store respectively. Logic Command returns an Output object which contains all neccessary
//details for the GUI to display.
class LogicCommand{
	CMParser _parser;								//To interpret descriptions, time and date
	CMStorage _storage;								//To store Task into files and change directory
	EditReader _editor;								//To edit Task in files
	ClashCheck _checker;							//To check if add Timed Task has clashes with previous task
	StringConvertor _stringConvertor;	

	bool _listType;
	std::string _feedback;
	std::vector <Task*> _taskList;					
	int _lastActionIndex;							//Index of Last User Action
	int _firstFloatIndex;							//Index for GUI to know where to seperate the float task in the list


public:
	Output* retrieveData();							
	Output* addTask (std::string,int,bool);			
	Output* addFloatTask(bool);						
	Output* addTimeTask(bool);						
	Output* addDeadlines(bool);
	Output* searchTask (std::string);
	Output* editTask(std::string);
	Output* deleteTask(std::string);
	Output* displayToday();
	Output* displayTomorrow();
	Output* undoAction();
	Output* clearTask();
	Output* checkTask(std::string);
	Output* checkCompletedTask();
	Output* uncheckTask(std::string);
	Output* changeStorageDirectory(std::string);
	Output* returnToHomePage();
};

#endif
	// End of segment: C:\users\joseph\desktop\v0.5\cmcode\CMLogic\LogicCommand.h





	/**
	 * origin: C:\users\joseph\desktop\v0.5\cmcode\CMLogic\LogicRead.cpp
	 */

#include <string>
#include <iostream>
#include <sstream>
#include "LogicRead.h"


Command* LogicRead :: interpretCommand(std::string input){
	std::istringstream userInput(input);
	std::string userCommand;	
	std::string description;	

	int commandIndex;

	if(userInput>>userCommand){
		commandIndex = indexCommand(userCommand);
	}else {commandIndex = INVALIDCOMMAND;}

	if(getline(userInput,description)){
		description=description.substr(1);
	}else{
		description="";}

	std::cout<<"2. LogicRead :"<<commandIndex<<" " <<description<<std::endl;
	Command* IndexedCommand = new Command(commandIndex,description);


	return IndexedCommand;
}


int LogicRead :: indexCommand(std::string NewCommand){

	std::string command = lowerCase(NewCommand); 

	if(command==ADD){
		return INDEXADD;
	}else if
		(command==SEARCH){
			return  INDEXSEARCH;
	}else if
		(command==EDIT){
			return INDEXEDIT;
	}else if
		(command==DEL){
			return INDEXDELETE;
	}else if
		(command==TODAY){
			return INDEXTODAY;
	}else if
		(command==TOMORROW){
			return INDEXTOMORROW;
	}else if
		(command==UNDO){
			return INDEXUNDO;
	}else if
		(command==EXIT){
			return INDEXEXIT;
	}else if
		(command==CHECK){
			return INDEXCHECKTASK;
	}else if
		(command==REDO){
			return INDEXUNDO;
	}else if
		(command==CLEAR){
			return INDEXCLEAR;
	}else if
		(command==COMPLETED){
			return INDEXCOMPLETED;
	}else if
		(command==UNCHECK){
			return INDEXUNCHECK;
	}else if
		(command==CHANGESTORE){
			return INDEXCHANGESTORE;
	}else if
		(command==HOME){
			return INDEXHOME;
	}else{
		return INVALIDCOMMAND;
	}
}

std::string LogicRead :: lowerCase(std::string commandInput){

	char newCase;
	for(unsigned int index = 0; index < commandInput.size();index++){
		if(isupper(commandInput[index])){ 
			newCase= tolower(commandInput[index]);
			commandInput[index] = newCase;
		}
	}
	return commandInput;
}
	// End of segment: C:\users\joseph\desktop\v0.5\cmcode\CMLogic\LogicRead.cpp





	/**
	 * origin: C:\users\joseph\desktop\v0.5\cmcode\CMLogic\LogicRead.h
	 */

#ifndef LOGICREAD_H
#define LOGICREAD_H

#include <iostream>
#include <string>
#include "Command.h"
//Expeceted commands which LogicRead will interpret.
const std::string ADD		= "add";
const std::string SEARCH	= "search";
const std::string EDIT		= "edit";
const std::string DEL		= "delete";
const std::string TODAY		= "today";
const std::string TOMORROW = "tomorrow";
const std::string UNDO		= "undo";
const std::string EXIT		= "exit";
const std::string CHECK		= "check";
const std::string REDO		= "redo";
const std::string CLEAR		= "clear";
const std::string COMPLETED = "completed";
const std::string UNCHECK	= "uncheck";
const std::string CHANGESTORE = "changestore";
const std::string HOME			= "home";


const int INDEXADD		 = 1;
const int INDEXSEARCH	 = 2;
const int INDEXEDIT		 = 3;
const int INDEXDELETE	 = 4;
const int INDEXTODAY	 = 5;
const int INDEXTOMORROW = 6;
const int INDEXUNDO		 = 7;
const int INDEXEXIT		 = 9;
const int INDEXCHECKTASK = 10;
const int INDEXCLEAR	 = 12;
const int INDEXCOMPLETED =13;
const int INDEXUNCHECK	 =14;
const int INDEXCHANGESTORE =15;
const int INDEXHOME		 =16;
const int INVALIDCOMMAND = 20;


//LogicRead inteprets the input into an index and a description.
//Helps CMLogic to determine the primary command of the user 
//and stores the remaining details into a string for LogicCommand to execute
class LogicRead{

public:
	int indexCommand(std::string);				//Indexes the command for a switch case
	Command* interpretCommand(std::string);		//Creates a Command object with the input string
	std::string lowerCase(std::string);			//Converts all command input into lower cases
};

#endif
	// End of segment: C:\users\joseph\desktop\v0.5\cmcode\CMLogic\LogicRead.h





	/**
	 * origin: C:\users\joseph\desktop\v0.5\cmcode\CMLogic\Output.cpp
	 */

#include "Output.h"

Output::Output(void){

	_feedback = "";
}

Output::Output(std::string feedback, std::vector<Task*> taskList,int actionIndex,int floatindex,bool listType){
	_feedback = feedback;
	_taskList = taskList;
	_lastActionIndex = actionIndex;
	_firstFloatIndex = floatindex;
	_listType= listType;
}

void Output::editFeedback(std::string newFeedback){
	_feedback = newFeedback;
}

std::string Output :: getFeedback() const{
	return _feedback;
}

std::vector < Task*> Output::getDisplay() const {
	return _taskList;
}

int Output::getLastAction() const{
	return _lastActionIndex;
}

int Output::getFirstFloat() const{
	return _firstFloatIndex;
}
bool Output::getListType() const{
	return _listType;
}
	// End of segment: C:\users\joseph\desktop\v0.5\cmcode\CMLogic\Output.cpp





	/**
	 * origin: C:\users\joseph\desktop\v0.5\cmcode\CMLogic\Output.h
	 */

#ifndef OUTPUT_H
#define OUTPUT_H

#include <iostream>
#include <vector>
#include "Task.h"

//Output is an object consolidating all important details
//for the GUI to display.
class Output{
	std::string _feedback;				//To acknowledge the commands of the user.
	std::vector <Task*> _taskList;		//The TaskList to display. (Can be completed or current Task)
	int _lastActionIndex;				//The index for the GUI to highlight so the User can easily identify his action
	int	_firstFloatIndex;				//The position for the GUI to know when to split the float task
	bool _listType;						//To indicate if User is accessing Active task or Archived

public:
	Output(void);
	Output(std::string, std::vector<Task*>,int,int,bool);

	void editFeedback(std::string);
	std::string getFeedback() const;
	std::vector <Task*> getDisplay() const;
	int getLastAction() const;
	int getFirstFloat() const;
	bool getListType() const;
};
#endif

	// End of segment: C:\users\joseph\desktop\v0.5\cmcode\CMLogic\Output.h





	/**
	 * origin: C:\users\joseph\desktop\v0.5\cmcode\CMLogic\StringConvertor.cpp
	 */

#include "StringConvertor.h"



std::vector<int> StringConvertor :: toInt(std::string stringIndex){
	int integer;
	std::string indexString = stringIndex;
	std::istringstream indexLine(stringIndex);
	std::vector <int> indexList;
	while(indexLine>>integer){
		indexList.push_back(integer);
	}
	std::sort(indexList.begin(),indexList.end());
	std::reverse(indexList.begin(),indexList.end());
	return indexList;
}


	// End of segment: C:\users\joseph\desktop\v0.5\cmcode\CMLogic\StringConvertor.cpp





	/**
	 * origin: C:\users\joseph\desktop\v0.5\cmcode\CMLogic\StringConvertor.h
	 */

#ifndef STRINGCONVERTOR_H
#define STRINGCONVERTOR_H
#include<vector>
#include<sstream>
#include<string>
#include <algorithm>

//StringConvertor helps Logic to interpret a string of integers
//in to vector of int so that a for loop can be done if there are
//multiple deletions, checking or unchecking
class StringConvertor
{
public:
		std::vector <int> toInt(std::string);
};

#endif
	// End of segment: C:\users\joseph\desktop\v0.5\cmcode\CMLogic\StringConvertor.h





	/**
	 * origin: C:\users\joseph\desktop\v0.5\cmcode\CMLogic\Task.cpp
	 */

#include "Task.h"
#include <iostream>
#include <algorithm>

Task::Task(std::string description)
{
	_description= description;
} 

Task::~Task(void)
{}

void Task:: editDescription(std::string NewDescription){
	_description = NewDescription;
}

std::string Task:: getDescription() const{
	return _description;
}


	// End of segment: C:\users\joseph\desktop\v0.5\cmcode\CMLogic\Task.cpp





	/**
	 * origin: C:\users\joseph\desktop\v0.5\cmcode\CMLogic\Task.h
	 */

#ifndef TASK_H
#define TASK_H

#include <iostream>
#include <string>

#include "boost/date_time.hpp"

const bool NOCLASH = false;
const bool CLASH = true;

//Abstract Base class of Floating Task/Deadlines/Timed Task.
//A task can be created, retrieved of information,deleted, edited
//checked for completion, checked for clash, checked for type.
class Task{
protected:
	std :: string _description;		//Describes what the task is about			

public:
	Task(std :: string);
	~Task();
	//For all three tasks
	void editDescription(std :: string);


	std :: string getDescription() const;


	virtual void editStartDate(boost::posix_time::ptime)=0;
	virtual void editStartTime (boost::posix_time::ptime)=0;
	virtual void editEndDate (boost::posix_time::ptime)=0;
	virtual void editEndTime (boost::posix_time::ptime)=0;

	virtual boost::posix_time::ptime getStart() const=0;
	virtual boost::posix_time::ptime getEnd() const=0;
	//Different attributes to search
	virtual bool isFound(std::string)=0;															//Returns true when string is found in any category
	virtual std :: string getInfo()=0;																//Returns a string of the comppiled details
	virtual bool hasClash(boost::posix_time::ptime,boost::posix_time::ptime)=0;						//Checks if the task clashes within a timeframe

	virtual bool isEditedTask(std::string, boost::posix_time::ptime, boost::posix_time::ptime)=0;	//To identify if task was the recently edited task)
	virtual bool isFloat()=0;
	virtual bool isTimed()=0;
	virtual bool isDeadline()=0;
};

#endif
	// End of segment: C:\users\joseph\desktop\v0.5\cmcode\CMLogic\Task.h





	/**
	 * origin: C:\users\joseph\desktop\v0.5\cmcode\CMLogic\TimedTask.cpp
	 */

#include <iomanip>
#include <sstream>
#include <algorithm>
#include<string>
#include "TimedTask.h"
#include<string>



TimedTask::TimedTask(std::string description,boost::posix_time::ptime start, boost::posix_time::ptime end)
	:Task(description){ 
		_start=start;
		_end =end;
}


TimedTask::~TimedTask(void)
{
}

void TimedTask:: editStartTime(boost::posix_time::ptime newStart){
	_start = newStart;
}

void TimedTask:: editEndTime (boost::posix_time::ptime newEnd){
	_end = newEnd;
}

void TimedTask:: editStartDate(boost::posix_time::ptime newStart){
	_start = newStart;
}

void TimedTask:: editEndDate (boost::posix_time::ptime newEnd){
	_end = newEnd;
}


boost::posix_time::ptime TimedTask:: getStart() const{
	return _start; }


boost::posix_time::ptime TimedTask:: getEnd() const{
	return _end;
}

bool TimedTask :: hasClash(boost::posix_time::ptime newStart, boost::posix_time::ptime newEnd){

	if((newEnd<=_start)||(newStart>=_end)){
		return NOCLASH;
	}else{
		return CLASH;
	}

}

bool TimedTask:: isFound (std::string keyword){
	bool found = false;
	size_t position;


	position = _description.find(keyword);
	if(position!= std::string::npos){
		return true;
	} else{
		position = to_simple_string(_start).find(keyword);
		if(position!= std::string::npos){
			return true;
		}else{
			position = to_simple_string(_end).find(keyword);
			if(position!= std::string::npos){
				return true;
			}
		}
	}

	return found;
}

std::string TimedTask:: getInfo() {
	std::ostringstream information;

	information <<std::left << std::setw(60)<<_description 
		<<std::setw(30)<<to_simple_string(_start)
		<<std::setw(30)<<to_simple_string(_end);

	return information.str();
}

bool TimedTask :: isFloat(){
	return false;
}

bool TimedTask :: isTimed(){
	return true;
}

bool TimedTask:: isDeadline(){
	return false;
}

bool TimedTask :: isEditedTask(std::string description, boost::posix_time::ptime start, boost::posix_time::ptime end){
	if(description==_description && start == _start&& end ==_end){
		return true;
	} else {
		return false;}
}
	// End of segment: C:\users\joseph\desktop\v0.5\cmcode\CMLogic\TimedTask.cpp





	/**
	 * origin: C:\users\joseph\desktop\v0.5\cmcode\CMLogic\TimedTask.h
	 */

#ifndef TIMEDTASK_H
#define TIMEDTASK_H
#include "Task.h"

//Timed Task is a task which contains the
//description, a start time/date and an end time/date for the user to 
//plan his eventse. All information will be shown to the user on the UI.
//Deadline is a subclass of Task.
class TimedTask : public Task{
private:
	boost::posix_time::ptime _start;
	boost::posix_time::ptime _end;

public:
	TimedTask(std::string,boost::posix_time::ptime,boost::posix_time::ptime);
	~TimedTask(void);

	virtual void editStartDate(boost::posix_time::ptime);
	virtual void editStartTime (boost::posix_time::ptime);
	virtual void editEndDate (boost::posix_time::ptime);
	virtual void editEndTime (boost::posix_time::ptime);

	virtual boost::posix_time::ptime getStart() const;
	virtual boost::posix_time::ptime getEnd() const;

	virtual bool hasClash(boost::posix_time::ptime,boost::posix_time::ptime);
	virtual std::string getInfo();
	virtual bool isFound (std::string);
	virtual bool isEditedTask(std::string, boost::posix_time::ptime, boost::posix_time::ptime);
	virtual bool isFloat();
	virtual bool isTimed();
	virtual bool isDeadline();
};

#endif
	// End of segment: C:\users\joseph\desktop\v0.5\cmcode\CMLogic\TimedTask.h





